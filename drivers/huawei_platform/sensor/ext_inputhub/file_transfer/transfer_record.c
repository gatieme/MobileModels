// SPDX-License-Identifier: GPL-2.0
/*
 * transfer_record.c
 *
 * the source file for file transfer records
 *
 * Copyright (c) 2022-2022 Huawei Technologies Co., Ltd.
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 */
#include "transfer_record.h"

#include <linux/list.h>
#include <linux/mutex.h>
#include <linux/random.h>
#include <linux/slab.h>
#include <huawei_platform/log/hw_log.h>

#define HWLOG_TAG file_trans
HWLOG_REGIST();

/* lock for transfer records */
static DEFINE_MUTEX(records_mutex);
static LIST_HEAD(transfer_record_list);

static u16 generate_rfd_random_low(void)
{
	u16 rand_rfd;

	get_random_bytes(&rand_rfd, sizeof(rand_rfd));
	return rand_rfd;
}

/*
 * left -> right (bit 31 ~ bit 16) rfd high 16 bits:
 * bit 31: symbol bit for mark the rfd valid( 1 is invalid)
 * bit 30 ~ bit 27: 4 bits for generator, AP generator 0x01
 * bit 26 ~ bit 23: 4 bits for transfer aim, AP aim 0x01
 * bit 22 ~ bit 19: 4 bits for transfer source, MCU source 0x02
 * bit 18 ~ bit 16: 3 bits for reserved
 */
static u16 generate_rfd_high(int8_t tid)
{
	/* 8 bits high, 3 bits reserved */
	return ((0x01 << 8) | tid) << 3;
}

static int32_t generate_rfd(u16 high, u16 low)
{
	/* 16 bits high */
	return ((high << 16) | low);
}

/*
 * left -> right (bit 16 ~ bit 0) rfd low 16 bits:
 * check from used list and get one not used (the list is order by low 16bits)
 */
static struct list_head *get_not_used(u16 *low)
{
	struct transfer_record *buf_node = NULL;
	struct transfer_record *prev_node = NULL;

	hwlog_info("%s get in", __func__);
	list_for_each_entry(buf_node, &transfer_record_list, list) {
		if (list_is_first(&buf_node->list, &transfer_record_list)) {
			prev_node = buf_node;
			continue;
		}
		/* get list between */
		if ((buf_node->rfd | 0x0000FFFF) - (prev_node->rfd | 0x0000FFFF) > 1) {
			*low = (prev_node->rfd | 0x0000FFFF) + 1;
			return &prev_node->list;
		}
		prev_node = buf_node;
		if (list_is_last(&buf_node->list, &transfer_record_list)) {
			/* cannot get one if last is 0x0000FFFF */
			if ((buf_node->rfd | 0x0000FFFF) == 0x0000FFFF)
				return NULL;

			*low = (u16)(buf_node->rfd | 0x0000FFFF) + 1;
			hwlog_info("%s get new node rfd2:%d", __func__, *low);
			return &buf_node->list;
		}
	}

	*low = 0;
	return &transfer_record_list;
}

struct transfer_record *generate_remote_record(int rfd)
{
	struct transfer_record *new_node = NULL;

	hwlog_info("%s get in", __func__);
	new_node = kmalloc(sizeof(*new_node), GFP_KERNEL);
	if (!new_node)
		return NULL;

	INIT_LIST_HEAD(&new_node->list);
	/* rfd is generated by remote, here just record */
	new_node->rfd = rfd;
	mutex_lock(&records_mutex);
	list_add_tail(&new_node->list, &transfer_record_list);
	mutex_unlock(&records_mutex);

	return new_node;
}

struct transfer_record *generate_available_record(int8_t tid)
{
	struct transfer_record *last_node = NULL;
	struct transfer_record *buf_node = NULL;
	struct transfer_record *tmp_node = NULL;
	struct transfer_record *new_node = NULL;
	struct list_head *find_list = NULL;
	/* first try to generate random record */
	u16 low = generate_rfd_random_low();

	hwlog_info("%s get in", __func__);
	new_node = kmalloc(sizeof(*new_node), GFP_KERNEL);
	if (!new_node)
		return NULL;

	INIT_LIST_HEAD(&new_node->list);

	mutex_lock(&records_mutex);
	/* sorted by rfd low 16bits */
	list_for_each_entry_safe(buf_node, tmp_node, &transfer_record_list, list) {
		if (low < (buf_node->rfd | 0x0000FFFF)) {
			/* random generated rfd is valid */
			new_node->rfd = generate_rfd(generate_rfd_high(tid), low);
			list_add_tail(&new_node->list, &buf_node->list);
			mutex_unlock(&records_mutex);
			return new_node;
		}
		last_node = buf_node;
		/* get same record */
		if (low == (buf_node->rfd | 0x0000FFFF))
			break;
	}
	/*
	 * here can get 3 situations
	 * 1: transfer_record_list is empty, then can use the rfd directly
	 * 2: low is the same which already contains in the list
	 * 3: low is greater than the last element in the list: then can use the rfd directly
	 */
	if (!last_node || low != (last_node->rfd | 0x0000FFFF)) {
		new_node->rfd = generate_rfd(generate_rfd_high(tid), low);
		list_add_tail(&new_node->list, &transfer_record_list);
		mutex_unlock(&records_mutex);
		return new_node;
	}
	/*
	 * here to deal 2 situations, try to get a rfd not used
	 * 1: get the same rfd record in list
	 * 2: get the same last one
	 */
	find_list = get_not_used(&low);
	if (!find_list) {
		kfree(new_node);
		mutex_unlock(&records_mutex);
		hwlog_err("%s get idle rfd fail", __func__);
		return NULL;
	}
	new_node->rfd = generate_rfd(generate_rfd_high(tid), low);
	list_add_tail(&new_node->list, find_list);
	mutex_unlock(&records_mutex);

	return new_node;
}

void release_record(struct transfer_record *record)
{
	if (!record)
		return;

	mutex_lock(&records_mutex);
	list_del(&record->list);
	mutex_unlock(&records_mutex);
	if (record->trans_info) {
		kfree(record->trans_info->file.local_path);
		kfree(record->trans_info);
	}
	kfree(record);
}
